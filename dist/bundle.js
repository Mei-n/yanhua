/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js/script.js":
/*!**********************!*\
  !*** ./js/script.js ***!
  \**********************/
/***/ (() => {

eval("\nconsole.clear();\n\nconst IS_MOBILE = window.innerWidth <= 640;\nconst IS_DESKTOP = window.innerWidth > 800;\nconst IS_HEADER = IS_DESKTOP && window.innerHeight < 300;\n\nconst IS_HIGH_END_DEVICE = (() => {\n\tconst hwConcurrency = navigator.hardwareConcurrency;\n\tif (!hwConcurrency) {\n\t\treturn false;\n\t}\n\n\tconst minCount = window.innerWidth <= 1024 ? 4 : 8;\n\treturn hwConcurrency >= minCount;\n})();\n\nconst MAX_WIDTH = 7680;\nconst MAX_HEIGHT = 4320;\nconst GRAVITY = 0.9;\nlet simSpeed = 1;\n\nfunction getDefaultScaleFactor() {\n\tif (IS_MOBILE) return 0.9;\n\tif (IS_HEADER) return 0.75;\n\treturn 1;\n}\n\n\nlet stageW, stageH;\n\n\nlet quality = 1;\nlet isLowQuality = false;\nlet isNormalQuality = true;\nlet isHighQuality = false;\n\nconst QUALITY_LOW = 1;\nconst QUALITY_NORMAL = 2;\nconst QUALITY_HIGH = 3;\n\nconst SKY_LIGHT_NONE = 0;\nconst SKY_LIGHT_DIM = 1;\nconst SKY_LIGHT_NORMAL = 2;\n\nconst COLOR = {\n\tRed: '#ff0043',\n\tGreen: '#14fc56',\n\tBlue: '#1e7fff',\n\tPurple: '#e60aff',\n\tGold: '#ffbf36',\n\tWhite: '#ffffff'\n};\n\n\nconst INVISIBLE = '_INVISIBLE_';\n\nconst PI_2 = Math.PI * 2;\nconst PI_HALF = Math.PI * 0.5;\n\n\nconst trailsStage = new Stage('trails-canvas');\nconst mainStage = new Stage('main-canvas');\nconst stages = [\n\ttrailsStage,\n\tmainStage\n];\n\n\n\n\nfunction fullscreenEnabled() {\n\treturn fscreen.fullscreenEnabled;\n}\n\n\nfunction isFullscreen() {\n\treturn !!fscreen.fullscreenElement;\n}\n\n\nfunction toggleFullscreen() {\n\tif (fullscreenEnabled()) {\n\t\tif (isFullscreen()) {\n\t\t\tfscreen.exitFullscreen();\n\t\t} else {\n\t\t\tfscreen.requestFullscreen(document.documentElement);\n\t\t}\n\t}\n}\n\n\nfscreen.addEventListener('fullscreenchange', () => {\n\tstore.setState({ fullscreen: isFullscreen() });\n});\n\n\n\n\n\nconst store = {\n\t_listeners: new Set(),\n\t_dispatch(prevState) {\n\t\tthis._listeners.forEach(listener => listener(this.state, prevState))\n\t},\n\t\n\tstate: {\n\n\t\tpaused: true,\n\t\tsoundEnabled: true,\n\t\tmenuOpen: false,\n\t\topenHelpTopic: null,\n\t\tfullscreen: isFullscreen(),\n\n\t\tconfig: {\n\t\t\tquality: String(IS_HIGH_END_DEVICE ? QUALITY_HIGH : QUALITY_NORMAL), // will be mirrored to a global variable named `quality` in `configDidUpdate`, for perf.\n\t\t\tshell: 'Random',\n\t\t\tsize: IS_DESKTOP\n\t\t\t\t? '3'\n\t\t\t\t: IS_HEADER \n\t\t\t\t\t? '1.2'\n\t\t\t\t\t: '2',\n\t\t\tautoLaunch: false,\n\t\t\tfinale: false,\n\t\t\tskyLighting: SKY_LIGHT_NORMAL + '',\n\t\t\thideControls: IS_HEADER,\n\t\t\tlongExposure: false,\n\t\t\tscaleFactor: getDefaultScaleFactor()\n\t\t}\n\t},\n\t\n\tsetState(nextState) {\n\t\tconst prevState = this.state;\n\t\tthis.state = Object.assign({}, this.state, nextState);\n\t\tthis._dispatch(prevState);\n\t\tthis.persist();\n\t},\n\t\n\tsubscribe(listener) {\n\t\tthis._listeners.add(listener);\n\t\treturn () => this._listeners.remove(listener);\n\t},\n\t\n\n\tload() {\n\t\tconst serializedData = localStorage.getItem('cm_fireworks_data');\n\t\tif (serializedData) {\n\t\t\tconst {\n\t\t\t\tschemaVersion,\n\t\t\t\tdata\n\t\t\t} = JSON.parse(serializedData);\n\t\t\t\n\t\t\tconst config = this.state.config;\n\t\t\tswitch(schemaVersion) {\n\t\t\t\tcase '1.1':\n\t\t\t\t\tconfig.quality = data.quality;\n\t\t\t\t\tconfig.size = data.size;\n\t\t\t\t\tconfig.skyLighting = data.skyLighting;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1.2':\n\t\t\t\t\tconfig.quality = data.quality;\n\t\t\t\t\tconfig.size = data.size;\n\t\t\t\t\tconfig.skyLighting = data.skyLighting;\n\t\t\t\t\tconfig.scaleFactor = data.scaleFactor;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('version switch should be exhaustive');\n\t\t\t}\n\t\t\tconsole.log(`Loaded config (schema version ${schemaVersion})`);\n\t\t}\n\n\t\telse if (localStorage.getItem('schemaVersion') === '1') {\n\t\t\tlet size;\n\n\t\t\ttry {\n\t\t\t\tconst sizeRaw = localStorage.getItem('configSize');\n\t\t\t\tsize = typeof sizeRaw === 'string' && JSON.parse(sizeRaw);\n\t\t\t}\n\t\t\tcatch(e) {\n\t\t\t\tconsole.log('Recovered from error parsing saved config:');\n\t\t\t\tconsole.error(e);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst sizeInt = parseInt(size, 10);\n\t\t\tif (sizeInt >= 0 && sizeInt <= 4) {\n\t\t\t\tthis.state.config.size = String(sizeInt);\n\t\t\t}\n\t\t}\n\t},\n\t\n\tpersist() {\n\t\tconst config = this.state.config;\n\t\tlocalStorage.setItem('cm_fireworks_data', JSON.stringify({\n\t\t\tschemaVersion: '1.2',\n\t\t\tdata: {\n\t\t\t\tquality: config.quality,\n\t\t\t\tsize: config.size,\n\t\t\t\tskyLighting: config.skyLighting,\n\t\t\t\tscaleFactor: config.scaleFactor\n\t\t\t}\n\t\t}));\n\t}\n};\n\n\nif (!IS_HEADER) {\n\tstore.load();\n}\n\n\n\nfunction togglePause(toggle) {\n\tconst paused = store.state.paused;\n\tlet newValue;\n\tif (typeof toggle === 'boolean') {\n\t\tnewValue = toggle;\n\t} else {\n\t\tnewValue = !paused;\n\t}\n\n\tif (paused !== newValue) {\n\t\tstore.setState({ paused: newValue });\n\t}\n}\n\nfunction toggleSound(toggle) {\n\tif (typeof toggle === 'boolean') {\n\t\tstore.setState({ soundEnabled: toggle });\n\t} else {\n\t\tstore.setState({ soundEnabled: !store.state.soundEnabled });\n\t}\n}\n\nfunction toggleMenu(toggle) {\n\tif (typeof toggle === 'boolean') {\n\t\tstore.setState({ menuOpen: toggle });\n\t} else {\n\t\tstore.setState({ menuOpen: !store.state.menuOpen });\n\t}\n}\n\nfunction updateConfig(nextConfig) {\n\tnextConfig = nextConfig || getConfigFromDOM();\n\tstore.setState({\n\t\tconfig: Object.assign({}, store.state.config, nextConfig)\n\t});\n\t\n\tconfigDidUpdate();\n}\n\n// Map config to various properties & apply side effects\nfunction configDidUpdate() {\n\tconst config = store.state.config;\n\t\n\tquality = qualitySelector();\n\tisLowQuality = quality === QUALITY_LOW;\n\tisNormalQuality = quality === QUALITY_NORMAL;\n\tisHighQuality = quality === QUALITY_HIGH;\n\t\n\tif (skyLightingSelector() === SKY_LIGHT_NONE) {\n\t\tappNodes.canvasContainer.style.backgroundColor = '#000';\n\t}\n\t\n\tSpark.drawWidth = quality === QUALITY_HIGH ? 0.75 : 1;\n}\n\n\n\nconst isRunning = (state=store.state) => !state.paused && !state.menuOpen;\n// Whether user has enabled sound.\nconst soundEnabledSelector = (state=store.state) => state.soundEnabled;\n// Whether any sounds are allowed, taking into account multiple factors.\nconst canPlaySoundSelector = (state=store.state) => isRunning(state) && soundEnabledSelector(state);\n// Convert quality to number.\nconst qualitySelector = () => +store.state.config.quality;\nconst shellNameSelector = () => store.state.config.shell;\n// Convert shell size to number.\nconst shellSizeSelector = () => +store.state.config.size;\nconst finaleSelector = () => store.state.config.finale;\nconst skyLightingSelector = () => +store.state.config.skyLighting;\nconst scaleFactorSelector = () => store.state.config.scaleFactor;\n\n\n\n// Help Content\nconst helpContent = {\n\tshellType: {\n\t\theader: '烟花类型',\n\t\tbody: '选择将要发射的烟花类型。 选择“随机”是一个不错的选择！'\n\t},\n\tshellSize: {\n\t\theader: '烟花大小',\n\t\tbody: '烟花的大小：以真实的烟花炮弹尺寸为模型，较大的炮弹具有更大的爆发力，带有更多的星星，有时效果更复杂。 但是，较大的尺寸还需要更多的处理能力，并且可能会导致延迟。'\n\t},\n\tquality: {\n\t\theader: '画质',\n\t\tbody: '整体图形质量。 如果动画运行不流畅，请尝试降低质量。 高质量会大大增加产生的火花数量，并可能导致滞后。'\n\t},\n\tskyLighting: {\n\t\theader: '天空照明',\n\t\tbody: '烟花爆炸时照亮背景。 如果背景在屏幕上看起来太亮，请尝试将其设置为“暗淡”或“无”。'\n\t},\n\tscaleFactor: {\n\t\theader: '规模',\n\t\tbody: '允许缩放所有烟花的大小，实质上使您靠近或远离。 对于较大的烟花类型，可以稍微减小比例，尤其是在手机或平板电脑上。'\n\t},\n\tautoLaunch: {\n\t\theader: '自动发射',\n\t\tbody: '启用此选项即可自动启动烟花序列，取消勾选你就可以手动控制烟花的发射'\n\t},\n\tfinaleMode: {\n\t\theader: '结局模式',\n\t\tbody: '发射强烈的烟花。 可能会导致延迟。 需要同时启用“自动发射”。'\n\t},\n\thideControls: {\n\t\theader: '隐藏控制器',\n\t\tbody: '隐藏屏幕顶部的半透明控件。 对于屏幕截图很有用，或者只是更无缝的体验。 隐藏后，您仍然可以点击右上角以重新打开此菜单。'\n\t},\n\tfullscreen: {\n\t\theader: '全屏',\n\t\tbody: '切换全屏模式。'\n\t},\n\tlongExposure: {\n\t\theader: '打开快门',\n\t\tbody: '实验效果可以保留长时间的光线，类似于保持相机快门打开。'\n\t}\n};\n\nconst nodeKeyToHelpKey = {\n\tshellTypeLabel: 'shellType',\n\tshellSizeLabel: 'shellSize',\n\tqualityLabel: 'quality',\n\tskyLightingLabel: 'skyLighting',\n\tscaleFactorLabel: 'scaleFactor',\n\tautoLaunchLabel: 'autoLaunch',\n\tfinaleModeLabel: 'finaleMode',\n\thideControlsLabel: 'hideControls',\n\tfullscreenLabel: 'fullscreen',\n\tlongExposureLabel: 'longExposure'\n};\n\n\n// Render app UI / keep in sync with state\nconst appNodes = {\n\tstageContainer: '.stage-container',\n\tcanvasContainer: '.canvas-container',\n\tcontrols: '.controls',\n\tmenu: '.menu',\n\tmenuInnerWrap: '.menu__inner-wrap',\n\tpauseBtn: '.pause-btn',\n\tpauseBtnSVG: '.pause-btn use',\n\tsoundBtn: '.sound-btn',\n\tsoundBtnSVG: '.sound-btn use',\n\tshellType: '.shell-type',\n\tshellTypeLabel: '.shell-type-label',\n\tshellSize: '.shell-size',\n\tshellSizeLabel: '.shell-size-label',\n\tquality: '.quality-ui',\n\tqualityLabel: '.quality-ui-label',\n\tskyLighting: '.sky-lighting',\n\tskyLightingLabel: '.sky-lighting-label',\n\tscaleFactor: '.scaleFactor',\n\tscaleFactorLabel: '.scaleFactor-label',\n\tautoLaunch: '.auto-launch',\n\tautoLaunchLabel: '.auto-launch-label',\n\tfinaleModeFormOption: '.form-option--finale-mode',\n\tfinaleMode: '.finale-mode',\n\tfinaleModeLabel: '.finale-mode-label',\n\thideControls: '.hide-controls',\n\thideControlsLabel: '.hide-controls-label',\n\tfullscreenFormOption: '.form-option--fullscreen',\n\tfullscreen: '.fullscreen',\n\tfullscreenLabel: '.fullscreen-label',\n\tlongExposure: '.long-exposure',\n\tlongExposureLabel: '.long-exposure-label',\n\t\n\t// Help UI\n\thelpModal: '.help-modal',\n\thelpModalOverlay: '.help-modal__overlay',\n\thelpModalHeader: '.help-modal__header',\n\thelpModalBody: '.help-modal__body',\n\thelpModalCloseBtn: '.help-modal__close-btn'\n};\n\n// Convert appNodes selectors to dom nodes\nObject.keys(appNodes).forEach(key => {\n\tappNodes[key] = document.querySelector(appNodes[key]);\n});\n\n// Remove fullscreen control if not supported.\nif (!fullscreenEnabled()) {\n\tappNodes.fullscreenFormOption.classList.add('remove');\n}\n\n// First render is called in init()\nfunction renderApp(state) {\n\t// const pauseBtnIcon = `#icon-${state.paused ? 'play' : 'pause'}`;\n\t// const soundBtnIcon = `#icon-sound-${soundEnabledSelector() ? 'on' : 'off'}`;\n\t// appNodes.pauseBtnSVG.setAttribute('href', pauseBtnIcon);\n\t// appNodes.pauseBtnSVG.setAttribute('xlink:href', pauseBtnIcon);\n\t// appNodes.soundBtnSVG.setAttribute('href', soundBtnIcon);\n\t// appNodes.soundBtnSVG.setAttribute('xlink:href', soundBtnIcon);\n\t// appNodes.controls.classList.toggle('hide', state.menuOpen || state.config.hideControls);\n\tappNodes.canvasContainer.classList.toggle('blur', state.menuOpen);\n\tappNodes.menu.classList.toggle('hide', !state.menuOpen);\n\tappNodes.finaleModeFormOption.style.opacity = state.config.autoLaunch ? 1 : 0.32;\n\t\n\tappNodes.quality.value = state.config.quality;\n\tappNodes.shellType.value = state.config.shell;\n\tappNodes.shellSize.value = state.config.size;\n\tappNodes.autoLaunch.checked = state.config.autoLaunch;\n\tappNodes.finaleMode.checked = state.config.finale;\n\tappNodes.skyLighting.value = state.config.skyLighting;\n\tappNodes.hideControls.checked = state.config.hideControls;\n\tappNodes.fullscreen.checked = state.fullscreen;\n\tappNodes.longExposure.checked = state.config.longExposure;\n\tappNodes.scaleFactor.value = state.config.scaleFactor.toFixed(2);\n\t\n\tappNodes.menuInnerWrap.style.opacity = state.openHelpTopic ? 0.12 : 1;\n\tappNodes.helpModal.classList.toggle('active', !!state.openHelpTopic);\n\tif (state.openHelpTopic) {\n\t\tconst { header, body } = helpContent[state.openHelpTopic];\n\t\tappNodes.helpModalHeader.textContent = header;\n\t\tappNodes.helpModalBody.textContent = body;\n\t}\n}\n\nstore.subscribe(renderApp);\n\n// Perform side effects on state changes\nfunction handleStateChange(state, prevState) {\n\tconst canPlaySound = canPlaySoundSelector(state);\n\tconst canPlaySoundPrev = canPlaySoundSelector(prevState);\n\t\n\tif (canPlaySound !== canPlaySoundPrev) {\n\t\tif (canPlaySound) {\n\t\t\tsoundManager.resumeAll();\n\t\t} else {\n\t\t\tsoundManager.pauseAll();\n\t\t}\n\t}\n}\n\nstore.subscribe(handleStateChange);\n\n\nfunction getConfigFromDOM() {\n\treturn {\n\t\tquality: appNodes.quality.value,\n\t\tshell: appNodes.shellType.value,\n\t\tsize: appNodes.shellSize.value,\n\t\tautoLaunch: appNodes.autoLaunch.checked,\n\t\tfinale: appNodes.finaleMode.checked,\n\t\tskyLighting: appNodes.skyLighting.value,\n\t\tlongExposure: appNodes.longExposure.checked,\n\t\thideControls: appNodes.hideControls.checked,\n\t\t// Store value as number.\n\t\tscaleFactor: parseFloat(appNodes.scaleFactor.value)\n\t};\n};\n\nconst updateConfigNoEvent = () => updateConfig();\nappNodes.quality.addEventListener('input', updateConfigNoEvent);\nappNodes.shellType.addEventListener('input', updateConfigNoEvent);\nappNodes.shellSize.addEventListener('input', updateConfigNoEvent);\nappNodes.autoLaunch.addEventListener('click', () => setTimeout(updateConfig, 0));\nappNodes.finaleMode.addEventListener('click', () => setTimeout(updateConfig, 0));\nappNodes.skyLighting.addEventListener('input', updateConfigNoEvent);\nappNodes.longExposure.addEventListener('click', () => setTimeout(updateConfig, 0));\nappNodes.hideControls.addEventListener('click', () => setTimeout(updateConfig, 0));\nappNodes.fullscreen.addEventListener('click', () => setTimeout(toggleFullscreen, 0));\n// Changing scaleFactor requires triggering resize handling code as well.\nappNodes.scaleFactor.addEventListener('input', () => {\n\tupdateConfig();\n\thandleResize();\n});\n\nObject.keys(nodeKeyToHelpKey).forEach(nodeKey => {\n\tconst helpKey = nodeKeyToHelpKey[nodeKey];\n\tappNodes[nodeKey].addEventListener('click', () => {\n\t\tstore.setState({ openHelpTopic: helpKey });\n\t});\n});\n\nappNodes.helpModalCloseBtn.addEventListener('click', () => {\n\tstore.setState({ openHelpTopic: null });\n});\n\nappNodes.helpModalOverlay.addEventListener('click', () => {\n\tstore.setState({ openHelpTopic: null });\n});\n\n\n\n// Constant derivations\nconst COLOR_NAMES = Object.keys(COLOR);\nconst COLOR_CODES = COLOR_NAMES.map(colorName => COLOR[colorName]);\n\nconst COLOR_CODES_W_INVIS = [...COLOR_CODES, INVISIBLE];\n\nconst COLOR_CODE_INDEXES = COLOR_CODES_W_INVIS.reduce((obj, code, i) => {\n\tobj[code] = i;\n\treturn obj;\n}, {});\n\nconst COLOR_TUPLES = {};\nCOLOR_CODES.forEach(hex => {\n\tCOLOR_TUPLES[hex] = {\n\t\tr: parseInt(hex.substr(1, 2), 16),\n\t\tg: parseInt(hex.substr(3, 2), 16),\n\t\tb: parseInt(hex.substr(5, 2), 16),\n\t};\n});\n\n// Get a random color.\nfunction randomColorSimple() {\n\treturn COLOR_CODES[Math.random() * COLOR_CODES.length | 0];\n}\n\n// Get a random color, with some customization options available.\nlet lastColor;\nfunction randomColor(options) {\n\tconst notSame = options && options.notSame;\n\tconst notColor = options && options.notColor;\n\tconst limitWhite = options && options.limitWhite;\n\tlet color = randomColorSimple();\n\t\n\t// limit the amount of white chosen randomly\n\tif (limitWhite && color === COLOR.White && Math.random() < 0.6) {\n\t\tcolor = randomColorSimple();\n\t}\n\t\n\tif (notSame) {\n\t\twhile (color === lastColor) {\n\t\t\tcolor = randomColorSimple();\n\t\t}\n\t}\n\telse if (notColor) {\n\t\twhile (color === notColor) {\n\t\t\tcolor = randomColorSimple();\n\t\t}\n\t}\n\t\n\tlastColor = color;\n\treturn color;\n}\n\nfunction whiteOrGold() {\n\treturn Math.random() < 0.5 ? COLOR.Gold : COLOR.White;\n}\n\n\n// Shell helpers\nfunction makePistilColor(shellColor) {\n\treturn (shellColor === COLOR.White || shellColor === COLOR.Gold) ? randomColor({ notColor: shellColor }) : whiteOrGold();\n}\n\n// Unique shell types\nconst crysanthemumShell = (size=1) => {\n\tconst glitter = Math.random() < 0.25;\n\tconst singleColor = Math.random() < 0.72;\n\tconst color = singleColor ? randomColor({ limitWhite: true }) : [randomColor(), randomColor({ notSame: true })];\n\tconst pistil = singleColor && Math.random() < 0.42;\n\tconst pistilColor = pistil && makePistilColor(color);\n\tconst secondColor = singleColor && (Math.random() < 0.2 || color === COLOR.White) ? pistilColor || randomColor({ notColor: color, limitWhite: true }) : null;\n\tconst streamers = !pistil && color !== COLOR.White && Math.random() < 0.42;\n\tlet starDensity = glitter ? 1.1 : 1.25;\n\tif (isLowQuality) starDensity *= 0.8;\n\tif (isHighQuality) starDensity = 1.2;\n\treturn {\n\t\tshellSize: size,\n\t\tspreadSize: 300 + size * 100,\n\t\tstarLife: 900 + size * 200,\n\t\tstarDensity,\n\t\tcolor,\n\t\tsecondColor,\n\t\tglitter: glitter ? 'light' : '',\n\t\tglitterColor: whiteOrGold(),\n\t\tpistil,\n\t\tpistilColor,\n\t\tstreamers\n\t};\n};\n\n\nconst ghostShell = (size=1) => {\n\t// Extend crysanthemum shell\n\tconst shell = crysanthemumShell(size);\n\t// Ghost effect can be fast, so extend star life\n\tshell.starLife *= 1.5;\n\t// Ensure we always have a single color other than white\n\tlet ghostColor = randomColor({ notColor: COLOR.White });\n\t// Always use streamers, and sometimes a pistil\n\tshell.streamers = true;\n\tconst pistil = Math.random() < 0.42;\n\tconst pistilColor = pistil && makePistilColor(ghostColor);\n\t// Ghost effect - transition from invisible to chosen color\n\tshell.color = INVISIBLE;\n\tshell.secondColor = ghostColor;\n\n\tshell.glitter = '';\n\t\n\treturn shell;\n};\n\n\nconst strobeShell = (size=1) => {\n\tconst color = randomColor({ limitWhite: true });\n\treturn {\n\t\tshellSize: size,\n\t\tspreadSize: 280 + size * 92,\n\t\tstarLife: 1100 + size * 200,\n\t\tstarLifeVariation: 0.40,\n\t\tstarDensity: 1.1,\n\t\tcolor,\n\t\tglitter: 'light',\n\t\tglitterColor: COLOR.White,\n\t\tstrobe: true,\n\t\tstrobeColor: Math.random() < 0.5 ? COLOR.White : null,\n\t\tpistil: Math.random() < 0.5,\n\t\tpistilColor: makePistilColor(color)\n\t};\n};\n\n\nconst palmShell = (size=1) => {\n\tconst color = randomColor();\n\tconst thick = Math.random() < 0.5;\n\treturn {\n\t\tshellSize: size,\n\t\tcolor,\n\t\tspreadSize: 250 + size * 75,\n\t\tstarDensity: thick ? 0.15 : 0.4,\n\t\tstarLife: 1800 + size * 200,\n\t\tglitter: thick ? 'thick' : 'heavy'\n\t};\n};\n\nconst ringShell = (size=1) => {\n\tconst color = randomColor();\n\tconst pistil = Math.random() < 0.75;\n\treturn {\n\t\tshellSize: size,\n\t\tring: true,\n\t\tcolor,\n\t\tspreadSize: 300 + size * 100,\n\t\tstarLife: 900 + size * 200,\n\t\tstarCount: 2.2 * PI_2 * (size+1),\n\t\tpistil,\n\t\tpistilColor: makePistilColor(color),\n\t\tglitter: !pistil ? 'light' : '',\n\t\tglitterColor: color === COLOR.Gold ? COLOR.Gold : COLOR.White,\n\t\tstreamers: Math.random() < 0.3\n\t};\n\t// return Object.assign({}, defaultShell, config);\n};\n\nconst crossetteShell = (size=1) => {\n\tconst color = randomColor({ limitWhite: true });\n\treturn {\n\t\tshellSize: size,\n\t\tspreadSize: 300 + size * 100,\n\t\tstarLife: 750 + size * 160,\n\t\tstarLifeVariation: 0.4,\n\t\tstarDensity: 0.85,\n\t\tcolor,\n\t\tcrossette: true,\n\t\tpistil: Math.random() < 0.5,\n\t\tpistilColor: makePistilColor(color)\n\t};\n};\n\nconst floralShell = (size=1) => ({\n\tshellSize: size,\n\tspreadSize: 300 + size * 120,\n\tstarDensity: 0.12,\n\tstarLife: 500 + size * 50,\n\tstarLifeVariation: 0.5,\n\tcolor: Math.random() < 0.65 ? 'random' : (Math.random() < 0.15 ? randomColor() : [randomColor(), randomColor({ notSame: true })]),\n\tfloral: true\n});\n\nconst fallingLeavesShell = (size=1) => ({\n\tshellSize: size,\n\tcolor: INVISIBLE,\n\tspreadSize: 300 + size * 120,\n\tstarDensity: 0.12,\n\tstarLife: 500 + size * 50,\n\tstarLifeVariation: 0.5,\n\tglitter: 'medium',\n\tglitterColor: COLOR.Gold,\n\tfallingLeaves: true\n});\n\nconst willowShell = (size=1) => ({\n\tshellSize: size,\n\tspreadSize: 300 + size * 100,\n\tstarDensity: 0.6,\n\tstarLife: 3000 + size * 300,\n\tglitter: 'willow',\n\tglitterColor: COLOR.Gold,\n\tcolor: INVISIBLE\n});\n\nconst crackleShell = (size=1) => {\n\t// favor gold\n\tconst color = Math.random() < 0.75 ? COLOR.Gold : randomColor();\n\treturn {\n\t\tshellSize: size,\n\t\tspreadSize: 380 + size * 75,\n\t\tstarDensity: isLowQuality ? 0.65 : 1,\n\t\tstarLife: 600 + size * 100,\n\t\tstarLifeVariation: 0.32,\n\t\tglitter: 'light',\n\t\tglitterColor: COLOR.Gold,\n\t\tcolor,\n\t\tcrackle: true,\n\t\tpistil: Math.random() < 0.65,\n\t\tpistilColor: makePistilColor(color)\n\t};\n};\n\nconst horsetailShell = (size=1) => {\n\tconst color = randomColor();\n\treturn {\n\t\tshellSize: size,\n\t\thorsetail: true,\n\t\tcolor,\n\t\tspreadSize: 250 + size * 38,\n\t\tstarDensity: 0.9,\n\t\tstarLife: 2500 + size * 300,\n\t\tglitter: 'medium',\n\t\tglitterColor: Math.random() < 0.5 ? whiteOrGold() : color,\n\t\t// Add strobe effect to white horsetails, to make them more interesting\n\t\tstrobe: color === COLOR.White\n\t};\n};\n\nfunction randomShellName() {\n\treturn Math.random() < 0.5 ? 'Crysanthemum' : shellNames[(Math.random() * (shellNames.length - 1) + 1) | 0 ];\n}\n\nfunction randomShell(size) {\n\t// Special selection for codepen header.\n\tif (IS_HEADER) return randomFastShell()(size);\n\t// Normal operation\n\treturn shellTypes[randomShellName()](size);\n}\n\nfunction shellFromConfig(size) {\n\treturn shellTypes[shellNameSelector()](size);\n}\n\n// Get a random shell, not including processing intensive varients\n// Note this is only random when \"Random\" shell is selected in config.\n// Also, this does not create the shell, only returns the factory function.\nconst fastShellBlacklist = ['Falling Leaves', 'Floral', 'Willow'];\nfunction randomFastShell() {\n\tconst isRandom = shellNameSelector() === 'Random';\n\tlet shellName = isRandom ? randomShellName() : shellNameSelector();\n\tif (isRandom) {\n\t\twhile (fastShellBlacklist.includes(shellName)) {\n\t\t\tshellName = randomShellName();\n\t\t}\n\t}\n\treturn shellTypes[shellName];\n}\n\n\nconst shellTypes = {\n\t'Random': randomShell,\n\t'Crackle': crackleShell,\n\t'Crossette': crossetteShell,\n\t'Crysanthemum': crysanthemumShell,\n\t'Falling Leaves': fallingLeavesShell,\n\t'Floral': floralShell,\n\t'Ghost': ghostShell,\n\t'Horse Tail': horsetailShell,\n\t'Palm': palmShell,\n\t'Ring': ringShell,\n\t'Strobe': strobeShell,\n\t'Willow': willowShell\n};\n\nconst shellNames = Object.keys(shellTypes);\n\nfunction init() {\n\t// Remove loading state\n\tdocument.querySelector('.loading-init').remove();\n\tappNodes.stageContainer.classList.remove('remove');\n\t\n\t// Populate dropdowns\n\tfunction setOptionsForSelect(node, options) {\n\t\tnode.innerHTML = options.reduce((acc, opt) => acc += `<option value=\"${opt.value}\">${opt.label}</option>`, '');\n\t}\n\n\t// shell type\n\tlet options = '';\n\tshellNames.forEach(opt => options += `<option value=\"${opt}\">${opt}</option>`);\n\tappNodes.shellType.innerHTML = options;\n\t// shell size\n\toptions = '';\n\t['3\"', '4\"', '6\"', '8\"', '12\"', '16\"'].forEach((opt, i) => options += `<option value=\"${i}\">${opt}</option>`);\n\tappNodes.shellSize.innerHTML = options;\n\t\n\tsetOptionsForSelect(appNodes.quality, [\n\t\t{ label: '低', value: QUALITY_LOW },\n\t\t{ label: '正常', value: QUALITY_NORMAL },\n\t\t{ label: '高', value: QUALITY_HIGH }\n\t]);\n\t\n\tsetOptionsForSelect(appNodes.skyLighting, [\n\t\t{ label: '无', value: SKY_LIGHT_NONE },\n\t\t{ label: '暗淡', value: SKY_LIGHT_DIM },\n\t\t{ label: '正常', value: SKY_LIGHT_NORMAL }\n\t]);\n\t\n\t// 0.9 is mobile default\n\tsetOptionsForSelect(\n\t\tappNodes.scaleFactor,\n\t\t[0.5, 0.62, 0.75, 0.9, 1.0, 1.5, 2.0]\n\t\t.map(value => ({ value: value.toFixed(2), label: `${value*100}%` }))\n\t);\n\t\n\t// Begin simulation\n\ttogglePause(false);\n\t\n\t// initial render\n\trenderApp(store.state);\n\t\n\t// Apply initial config\n\tconfigDidUpdate();\n}\n\n\nfunction fitShellPositionInBoundsH(position) {\n\tconst edge = 0.18;\n\treturn (1 - edge*2) * position + edge;\n}\n\nfunction fitShellPositionInBoundsV(position) {\n\treturn position * 0.75;\n}\n\nfunction getRandomShellPositionH() {\n\treturn fitShellPositionInBoundsH(Math.random());\n}\n\nfunction getRandomShellPositionV() {\n\treturn fitShellPositionInBoundsV(Math.random());\n}\n\nfunction getRandomShellSize() {\n\tconst baseSize = shellSizeSelector();\n\tconst maxVariance = Math.min(2.5, baseSize);\n\tconst variance = Math.random() * maxVariance;\n\tconst size = baseSize - variance;\n\tconst height = maxVariance === 0 ? Math.random() : 1 - (variance / maxVariance);\n\tconst centerOffset = Math.random() * (1 - height * 0.65) * 0.5;\n\tconst x = Math.random() < 0.5 ? 0.5 - centerOffset : 0.5 + centerOffset;\n\treturn {\n\t\tsize,\n\t\tx: fitShellPositionInBoundsH(x),\n\t\theight: fitShellPositionInBoundsV(height)\n\t};\n}\n\n\n// Launches a shell from a user pointer event, based on state.config\nfunction launchShellFromConfig(event) {\n\tconst shell = new Shell(shellFromConfig(shellSizeSelector()));\n\tconst w = mainStage.width;\n\tconst h = mainStage.height;\n\t\n\tshell.launch(\n\t\tevent ? event.x / w : getRandomShellPositionH(),\n\t\tevent ? 1 - event.y / h : getRandomShellPositionV()\n\t);\n}\n\n\n// Sequences\n// -----------\n\nfunction seqRandomShell() {\n\tconst size = getRandomShellSize();\n\tconst shell = new Shell(shellFromConfig(size.size));\n\tshell.launch(size.x, size.height);\n\t\n\tlet extraDelay = shell.starLife;\n\tif (shell.fallingLeaves) {\n\t\textraDelay = 4600;\n\t}\n\t\n\treturn 900 + Math.random() * 600 + extraDelay;\n}\n\nfunction seqRandomFastShell() {\n\tconst shellType = randomFastShell();\n\tconst size = getRandomShellSize();\n\tconst shell = new Shell(shellType(size.size));\n\tshell.launch(size.x, size.height);\n\t\n\tlet extraDelay = shell.starLife;\n\t\n\treturn 900 + Math.random() * 600 + extraDelay;\n}\n\nfunction seqTwoRandom() {\n\tconst size1 = getRandomShellSize();\n\tconst size2 = getRandomShellSize();\n\tconst shell1 = new Shell(shellFromConfig(size1.size));\n\tconst shell2 = new Shell(shellFromConfig(size2.size));\n\tconst leftOffset = Math.random() * 0.2 - 0.1;\n\tconst rightOffset = Math.random() * 0.2 - 0.1;\n\tshell1.launch(0.3 + leftOffset, size1.height);\n\tsetTimeout(() => {\n\t\tshell2.launch(0.7 + rightOffset, size2.height);\n\t}, 100);\n\t\n\tlet extraDelay = Math.max(shell1.starLife, shell2.starLife);\n\tif (shell1.fallingLeaves || shell2.fallingLeaves) {\n\t\textraDelay = 4600;\n\t}\n\t\n\treturn 900 + Math.random() * 600 + extraDelay;\n}\n\nfunction seqTriple() {\n\tconst shellType = randomFastShell();\n\tconst baseSize = shellSizeSelector();\n\tconst smallSize = Math.max(0, baseSize - 1.25);\n\t\n\tconst offset = Math.random() * 0.08 - 0.04;\n\tconst shell1 = new Shell(shellType(baseSize));\n\tshell1.launch(0.5 + offset, 0.7);\n\t\n\tconst leftDelay = 1000 + Math.random() * 400;\n\tconst rightDelay = 1000 + Math.random() * 400;\n\t\n\tsetTimeout(() => {\n\t\tconst offset = Math.random() * 0.08 - 0.04;\n\t\tconst shell2 = new Shell(shellType(smallSize));\n\t\tshell2.launch(0.2 + offset, 0.1);\n\t}, leftDelay);\n\t\n\tsetTimeout(() => {\n\t\tconst offset = Math.random() * 0.08 - 0.04;\n\t\tconst shell3 = new Shell(shellType(smallSize));\n\t\tshell3.launch(0.8 + offset, 0.1);\n\t}, rightDelay);\n\t\n\treturn 4000;\n}\n\nfunction seqPyramid() {\n\tconst barrageCountHalf = IS_DESKTOP ? 7 : 4;\n\tconst largeSize = shellSizeSelector();\n\tconst smallSize = Math.max(0, largeSize - 3);\n\tconst randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell;\n\tconst randomSpecialShell = randomShell;\n\n\tfunction launchShell(x, useSpecial) {\n\t\tconst isRandom = shellNameSelector() === 'Random';\n\t\tlet shellType = isRandom\n\t\t\t? useSpecial ? randomSpecialShell : randomMainShell\n\t\t\t: shellTypes[shellNameSelector()];\n\t\tconst shell = new Shell(shellType(useSpecial ? largeSize : smallSize));\n\t\tconst height = x <= 0.5 ? x / 0.5 : (1 - x) / 0.5;\n\t\tshell.launch(x, useSpecial ? 0.75 : height * 0.42);\n\t}\n\t\n\tlet count = 0;\n\tlet delay = 0;\n\twhile(count <= barrageCountHalf) {\n\t\tif (count === barrageCountHalf) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tlaunchShell(0.5, true);\n\t\t\t}, delay);\n\t\t} else {\n\t\t\tconst offset = count / barrageCountHalf * 0.5;\n\t\t\tconst delayOffset = Math.random() * 30 + 30;\n\t\t\tsetTimeout(() => {\n\t\t\t\tlaunchShell(offset, false);\n\t\t\t}, delay);\n\t\t\tsetTimeout(() => {\n\t\t\t\tlaunchShell(1 - offset, false);\n\t\t\t}, delay + delayOffset);\n\t\t}\n\t\t\n\t\tcount++;\n\t\tdelay += 200;\n\t}\n\t\n\treturn 3400 + barrageCountHalf * 250;\n}\n\nfunction seqSmallBarrage() {\n\tseqSmallBarrage.lastCalled = Date.now();\n\tconst barrageCount = IS_DESKTOP ? 11 : 5;\n\tconst specialIndex = IS_DESKTOP ? 3 : 1;\n\tconst shellSize = Math.max(0, shellSizeSelector() - 2);\n\tconst randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell;\n\tconst randomSpecialShell = randomFastShell();\n\t\n\n\tfunction launchShell(x, useSpecial) {\n\t\tconst isRandom = shellNameSelector() === 'Random';\n\t\tlet shellType = isRandom\n\t\t\t? useSpecial ? randomSpecialShell : randomMainShell\n\t\t\t: shellTypes[shellNameSelector()];\n\t\tconst shell = new Shell(shellType(shellSize));\n\t\tconst height = (Math.cos(x*5*Math.PI + PI_HALF) + 1) / 2;\n\t\tshell.launch(x, height * 0.75);\n\t}\n\t\n\tlet count = 0;\n\tlet delay = 0;\n\twhile(count < barrageCount) {\n\t\tif (count === 0) {\n\t\t\tlaunchShell(0.5, false)\n\t\t\tcount += 1;\n\t\t}\n\t\telse {\n\t\t\tconst offset = (count + 1) / barrageCount / 2;\n\t\t\tconst delayOffset = Math.random() * 30 + 30;\n\t\t\tconst useSpecial = count === specialIndex;\n\t\t\tsetTimeout(() => {\n\t\t\t\tlaunchShell(0.5 + offset, useSpecial);\n\t\t\t}, delay);\n\t\t\tsetTimeout(() => {\n\t\t\t\tlaunchShell(0.5 - offset, useSpecial);\n\t\t\t}, delay + delayOffset);\n\t\t\tcount += 2;\n\t\t}\n\t\tdelay += 200;\n\t}\n\t\n\treturn 3400 + barrageCount * 120;\n}\nseqSmallBarrage.cooldown = 15000;\nseqSmallBarrage.lastCalled = Date.now();\n\n\nconst sequences = [\n\tseqRandomShell,\n\tseqTwoRandom,\n\tseqTriple,\n\tseqPyramid,\n\tseqSmallBarrage\n];\n\n\nlet isFirstSeq = true;\nconst finaleCount = 32;\nlet currentFinaleCount = 0;\nfunction startSequence() {\n\tif (isFirstSeq) {\n\t\tisFirstSeq = false;\n\t\tif (IS_HEADER) {\n\t\t\treturn seqTwoRandom();\n\t\t}\n\t\telse {\n\t\t\tconst shell = new Shell(crysanthemumShell(shellSizeSelector()));\n\t\t\tshell.launch(0.5, 0.5);\n\t\t\treturn 2400;\n\t\t}\n\t}\n\t\n\tif (finaleSelector()) {\n\t\tseqRandomFastShell();\n\t\tif (currentFinaleCount < finaleCount) {\n\t\t\tcurrentFinaleCount++;\n\t\t\treturn 170;\n\t\t}\n\t\telse {\n\t\t\tcurrentFinaleCount = 0;\n\t\t\treturn 6000;\n\t\t}\n\t}\n\t\n\tconst rand = Math.random();\n\t\n\tif (rand < 0.08 && Date.now() - seqSmallBarrage.lastCalled > seqSmallBarrage.cooldown) {\n\t\treturn seqSmallBarrage();\n\t}\n\t\n\tif (rand < 0.1) {\n\t\treturn seqPyramid();\n\t}\n\t\n\tif (rand < 0.6 && !IS_HEADER) {\n\t\treturn seqRandomShell();\n\t}\n\telse if (rand < 0.8) {\n\t\treturn seqTwoRandom();\n\t}\n\telse if (rand < 1) {\n\t\treturn seqTriple();\n\t}\n}\n\n\nlet activePointerCount = 0;\nlet isUpdatingSpeed = false;\n\nfunction handlePointerStart(event) {\n\tactivePointerCount++;\n\tconst btnSize = 50;\n\t\n\tif (event.y < btnSize) {\n\t\tif (event.x < btnSize) {\n\t\t\ttogglePause();\n\t\t\treturn;\n\t\t}\n\t\tif (event.x > mainStage.width/2 - btnSize/2 && event.x < mainStage.width/2 + btnSize/2) {\n\t\t\ttoggleSound();\n\t\t\treturn;\n\t\t}\n\t\tif (event.x > mainStage.width - btnSize) {\n\t\t\ttoggleMenu();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tif (!isRunning()) return;\n\t\n\tif (updateSpeedFromEvent(event)) {\n\t\tisUpdatingSpeed = true;\n\t}\n\telse if (event.onCanvas) {\n\t\tlaunchShellFromConfig(event);\n\t}\n}\n\nfunction handlePointerEnd(event) {\n\tactivePointerCount--;\n\tisUpdatingSpeed = false;\n}\n\nfunction handlePointerMove(event) {\n\tif (!isRunning()) return;\n\t\n\tif (isUpdatingSpeed) {\n\t\tupdateSpeedFromEvent(event);\n\t}\n}\n\nfunction handleKeydown(event) {\n\t// P\n\tif (event.keyCode === 80) {\n\t\ttogglePause();\n\t}\n\t// O\n\telse if (event.keyCode === 79) {\n\t\ttoggleMenu();\n\t}\n\t// Esc\n\telse if (event.keyCode === 27) {\n\t\ttoggleMenu(false);\n\t}\n}\n\nmainStage.addEventListener('pointerstart', handlePointerStart);\nmainStage.addEventListener('pointerend', handlePointerEnd);\nmainStage.addEventListener('pointermove', handlePointerMove);\nwindow.addEventListener('keydown', handleKeydown);\n\n\n// Account for window resize and custom scale changes.\nfunction handleResize() {\n\tconst w = window.innerWidth;\n\tconst h = window.innerHeight;\n\t// Try to adopt screen size, heeding maximum sizes specified\n\tconst containerW = Math.min(w, MAX_WIDTH);\n\t// On small screens, use full device height\n\tconst containerH = w <= 420 ? h : Math.min(h, MAX_HEIGHT);\n\tappNodes.stageContainer.style.width = containerW + 'px';\n\tappNodes.stageContainer.style.height = containerH + 'px';\n\tstages.forEach(stage => stage.resize(containerW, containerH));\n\t// Account for scale\n\tconst scaleFactor = scaleFactorSelector();\n\tstageW = containerW / scaleFactor;\n\tstageH = containerH / scaleFactor;\n}\n\n// Compute initial dimensions\nhandleResize();\n\nwindow.addEventListener('resize', handleResize);\n\n\n// Dynamic globals\nlet currentFrame = 0;\nlet speedBarOpacity = 0;\nlet autoLaunchTime = 0;\n\nfunction updateSpeedFromEvent(event) {\n\tif (isUpdatingSpeed || event.y >= mainStage.height - 44) {\n\n\t\tconst edge = 16;\n\t\tconst newSpeed = (event.x - edge) / (mainStage.width - edge * 2);\n\t\tsimSpeed = Math.min(Math.max(newSpeed, 0), 1);\n\t\t// show speed bar after an update\n\t\tspeedBarOpacity = 1;\n\t\t// If we updated the speed, return true\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\n\nfunction updateGlobals(timeStep, lag) {\n\tcurrentFrame++;\n\t\n\t// Always try to fade out speed bar\n\tif (!isUpdatingSpeed) {\n\tspeedBarOpacity -= lag / 30; // half a second\n\t\tif (speedBarOpacity < 0) {\n\t\t\tspeedBarOpacity = 0;\n\t\t}\n\t}\n\t\n\t// auto launch shells\n\tif (store.state.config.autoLaunch) {\n\t\tautoLaunchTime -= timeStep;\n\t\tif (autoLaunchTime <= 0) {\n\t\t\tautoLaunchTime = startSequence() * 1.25;\n\t\t}\n\t}\n}\n\n\nfunction update(frameTime, lag) {\n\tif (!isRunning()) return;\n\t\n\tconst width = stageW;\n\tconst height = stageH;\n\tconst timeStep = frameTime * simSpeed;\n\tconst speed = simSpeed * lag;\n\t\n\tupdateGlobals(timeStep, lag);\n\t\n\tconst starDrag = 1 - (1 - Star.airDrag) * speed;\n\tconst starDragHeavy = 1 - (1 - Star.airDragHeavy) * speed;\n\tconst sparkDrag = 1 - (1 - Spark.airDrag) * speed;\n\tconst gAcc = timeStep / 1000 * GRAVITY;\n\tCOLOR_CODES_W_INVIS.forEach(color => {\n\t\t// Stars\n\t\tconst stars = Star.active[color];\n\t\tfor (let i=stars.length-1; i>=0; i=i-1) {\n\t\t\tconst star = stars[i];\n\t\t\tif (star.updateFrame === currentFrame) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstar.updateFrame = currentFrame;\n\t\t\t\n\t\t\tstar.life -= timeStep;\n\t\t\tif (star.life <= 0) {\n\t\t\t\tstars.splice(i, 1);\n\t\t\t\tStar.returnInstance(star);\n\t\t\t} else {\n\t\t\t\tconst burnRate = Math.pow(star.life / star.fullLife, 0.5);\n\t\t\t\tconst burnRateInverse = 1 - burnRate;\n\n\t\t\t\tstar.prevX = star.x;\n\t\t\t\tstar.prevY = star.y;\n\t\t\t\tstar.x += star.speedX * speed;\n\t\t\t\tstar.y += star.speedY * speed;\n\n\t\t\t\tif (!star.heavy) {\n\t\t\t\t\tstar.speedX *= starDrag;\n\t\t\t\t\tstar.speedY *= starDrag;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstar.speedX *= starDragHeavy;\n\t\t\t\t\tstar.speedY *= starDragHeavy;\n\t\t\t\t}\n\t\t\t\tstar.speedY += gAcc;\n\t\t\t\t\n\t\t\t\tif (star.spinRadius) {\n\t\t\t\t\tstar.spinAngle += star.spinSpeed * speed;\n\t\t\t\t\tstar.x += Math.sin(star.spinAngle) * star.spinRadius * speed;\n\t\t\t\t\tstar.y += Math.cos(star.spinAngle) * star.spinRadius * speed;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (star.sparkFreq) {\n\t\t\t\t\tstar.sparkTimer -= timeStep;\n\t\t\t\t\twhile (star.sparkTimer < 0) {\n\t\t\t\t\t\tstar.sparkTimer += star.sparkFreq * 0.75 + star.sparkFreq * burnRateInverse * 4;\n\t\t\t\t\t\tSpark.add(\n\t\t\t\t\t\t\tstar.x,\n\t\t\t\t\t\t\tstar.y,\n\t\t\t\t\t\t\tstar.sparkColor,\n\t\t\t\t\t\t\tMath.random() * PI_2,\n\t\t\t\t\t\t\tMath.random() * star.sparkSpeed * burnRate,\n\t\t\t\t\t\t\tstar.sparkLife * 0.8 + Math.random() * star.sparkLifeVariation * star.sparkLife\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Handle star transitions\n\t\t\t\tif (star.life < star.transitionTime) {\n\t\t\t\t\tif (star.secondColor && !star.colorChanged) {\n\t\t\t\t\t\tstar.colorChanged = true;\n\t\t\t\t\t\tstar.color = star.secondColor;\n\t\t\t\t\t\tstars.splice(i, 1);\n\t\t\t\t\t\tStar.active[star.secondColor].push(star);\n\t\t\t\t\t\tif (star.secondColor === INVISIBLE) {\n\t\t\t\t\t\t\tstar.sparkFreq = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (star.strobe) {\n\t\t\t\t\t\t// Strobes in the following pattern: on:off:off:on:off:off in increments of `strobeFreq` ms.\n\t\t\t\t\t\tstar.visible = Math.floor(star.life / star.strobeFreq) % 3 === 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\n\t\t// Sparks\n\t\tconst sparks = Spark.active[color];\n\t\tfor (let i=sparks.length-1; i>=0; i=i-1) {\n\t\t\tconst spark = sparks[i];\n\t\t\tspark.life -= timeStep;\n\t\t\tif (spark.life <= 0) {\n\t\t\t\tsparks.splice(i, 1);\n\t\t\t\tSpark.returnInstance(spark);\n\t\t\t} else {\n\t\t\t\tspark.prevX = spark.x;\n\t\t\t\tspark.prevY = spark.y;\n\t\t\t\tspark.x += spark.speedX * speed;\n\t\t\t\tspark.y += spark.speedY * speed;\n\t\t\t\tspark.speedX *= sparkDrag;\n\t\t\t\tspark.speedY *= sparkDrag;\n\t\t\t\tspark.speedY += gAcc;\n\t\t\t}\n\t\t}\n\t});\n\t\n\trender(speed);\n}\n\nfunction render(speed) {\n\tconst { dpr } = mainStage;\n\tconst width = stageW;\n\tconst height = stageH;\n\tconst trailsCtx = trailsStage.ctx;\n\tconst mainCtx = mainStage.ctx;\n\t\n\tif (skyLightingSelector() !== SKY_LIGHT_NONE) {\n\t\tcolorSky(speed);\n\t}\n\t\n\t// Account for high DPI screens, and custom scale factor.\n\tconst scaleFactor = scaleFactorSelector();\n\ttrailsCtx.scale(dpr * scaleFactor, dpr * scaleFactor);\n\tmainCtx.scale(dpr * scaleFactor, dpr * scaleFactor);\n\t\n\ttrailsCtx.globalCompositeOperation = 'source-over';\n\ttrailsCtx.fillStyle = `rgba(0, 0, 0, ${store.state.config.longExposure ? 0.0025 : 0.175 * speed})`;\n\ttrailsCtx.fillRect(0, 0, width, height);\n\t\n\tmainCtx.clearRect(0, 0, width, height);\n\t\n\t// Draw queued burst flashes\n\t// These must also be drawn using source-over due to Safari. Seems rendering the gradients using lighten draws large black boxes instead.\n\t// Thankfully, these burst flashes look pretty much the same either way.\n\twhile (BurstFlash.active.length) {\n\t\tconst bf = BurstFlash.active.pop();\n\t\t\n\t\tconst burstGradient = trailsCtx.createRadialGradient(bf.x, bf.y, 0, bf.x, bf.y, bf.radius);\n\t\tburstGradient.addColorStop(0.024, 'rgba(255, 255, 255, 1)');\n\t\tburstGradient.addColorStop(0.125, 'rgba(255, 160, 20, 0.2)');\n\t\tburstGradient.addColorStop(0.32, 'rgba(255, 140, 20, 0.11)');\n\t\tburstGradient.addColorStop(1, 'rgba(255, 120, 20, 0)');\n\t\ttrailsCtx.fillStyle = burstGradient;\n\t\ttrailsCtx.fillRect(bf.x - bf.radius, bf.y - bf.radius, bf.radius * 2, bf.radius * 2);\n\t\t\n\t\tBurstFlash.returnInstance(bf);\n\t}\n\t\n\t// Remaining drawing on trails canvas will use 'lighten' blend mode\n\ttrailsCtx.globalCompositeOperation = 'lighten';\n\n\ttrailsCtx.lineWidth = Star.drawWidth;\n\ttrailsCtx.lineCap = isLowQuality ? 'square' : 'round';\n\tmainCtx.strokeStyle = '#fff';\n    mainCtx.lineWidth = 1;\n\tmainCtx.beginPath();\n\tCOLOR_CODES.forEach(color => {\n\t\tconst stars = Star.active[color];\n\t\ttrailsCtx.strokeStyle = color;\n\t\ttrailsCtx.beginPath();\n\t\tstars.forEach(star => {\n\t\t\tif (star.visible) {\n\t\t\t\ttrailsCtx.moveTo(star.x, star.y);\n\t\t\t\ttrailsCtx.lineTo(star.prevX, star.prevY);\n\t\t\t\tmainCtx.moveTo(star.x, star.y);\n\t\t\t\tmainCtx.lineTo(star.x - star.speedX * 1.6, star.y - star.speedY * 1.6);\n\t\t\t}\n\t\t});\n\t\ttrailsCtx.stroke();\n\t});\n\tmainCtx.stroke();\n\n\t// Draw sparks\n\ttrailsCtx.lineWidth = Spark.drawWidth;\n\ttrailsCtx.lineCap = 'butt';\n\tCOLOR_CODES.forEach(color => {\n\t\tconst sparks = Spark.active[color];\n\t\ttrailsCtx.strokeStyle = color;\n\t\ttrailsCtx.beginPath();\n\t\tsparks.forEach(spark => {\n\t\t\ttrailsCtx.moveTo(spark.x, spark.y);\n\t\t\ttrailsCtx.lineTo(spark.prevX, spark.prevY);\n\t\t});\n\t\ttrailsCtx.stroke();\n\t});\n\t\n\t\n\t// Render speed bar if visible\n\tif (speedBarOpacity) {\n\t\tconst speedBarHeight = 6;\n\t\tmainCtx.globalAlpha = speedBarOpacity;\n\t\tmainCtx.fillStyle = COLOR.Blue;\n\t\tmainCtx.fillRect(0, height - speedBarHeight, width * simSpeed, speedBarHeight);\n\t\tmainCtx.globalAlpha = 1;\n\t}\n\t\n\t\n\ttrailsCtx.setTransform(1, 0, 0, 1, 0, 0);\n\tmainCtx.setTransform(1, 0, 0, 1, 0, 0);\n}\n\n\n// Draw colored overlay based on combined brightness of stars (light up the sky!)\n// Note: this is applied to the canvas container's background-color, so it's behind the particles\nconst currentSkyColor = { r: 0, g: 0, b: 0 };\nconst targetSkyColor = { r: 0, g: 0, b: 0 };\nfunction colorSky(speed) {\n\t// The maximum r, g, or b value that will be used (255 would represent no maximum)\n\tconst maxSkySaturation = skyLightingSelector() * 15;\n\t// How many stars are required in total to reach maximum sky brightness\n\tconst maxStarCount = 500;\n\tlet totalStarCount = 0;\n\t// Initialize sky as black\n\ttargetSkyColor.r = 0;\n\ttargetSkyColor.g = 0;\n\ttargetSkyColor.b = 0;\n\tCOLOR_CODES.forEach(color => {\n\t\tconst tuple = COLOR_TUPLES[color];\n\t\tconst count =  Star.active[color].length;\n\t\ttotalStarCount += count;\n\t\ttargetSkyColor.r += tuple.r * count;\n\t\ttargetSkyColor.g += tuple.g * count;\n\t\ttargetSkyColor.b += tuple.b * count;\n\t});\n\t\n\n\tconst intensity = Math.pow(Math.min(1, totalStarCount / maxStarCount), 0.3);\n\n\tconst maxColorComponent = Math.max(1, targetSkyColor.r, targetSkyColor.g, targetSkyColor.b);\n\n\ttargetSkyColor.r = targetSkyColor.r / maxColorComponent * maxSkySaturation * intensity;\n\ttargetSkyColor.g = targetSkyColor.g / maxColorComponent * maxSkySaturation * intensity;\n\ttargetSkyColor.b = targetSkyColor.b / maxColorComponent * maxSkySaturation * intensity;\n\t\n\n\tconst colorChange = 10;\n\tcurrentSkyColor.r += (targetSkyColor.r - currentSkyColor.r) / colorChange * speed;\n\tcurrentSkyColor.g += (targetSkyColor.g - currentSkyColor.g) / colorChange * speed;\n\tcurrentSkyColor.b += (targetSkyColor.b - currentSkyColor.b) / colorChange * speed;\n\t\n\tappNodes.canvasContainer.style.backgroundColor = `rgb(${currentSkyColor.r | 0}, ${currentSkyColor.g | 0}, ${currentSkyColor.b | 0})`;\n}\n\nmainStage.addEventListener('ticker', update);\n\n\n\nfunction createParticleArc(start, arcLength, count, randomness, particleFactory) {\n\tconst angleDelta = arcLength / count;\n\t// Sometimes there is an extra particle at the end, too close to the start. Subtracting half the angleDelta ensures that is skipped.\n\t// Would be nice to fix this a better way.\n\tconst end = start + arcLength - (angleDelta * 0.5);\n\t\n\tif (end > start) {\n\t\t// Optimization: `angle=angle+angleDelta` vs. angle+=angleDelta\n\t\t// V8 deoptimises with let compound assignment\n\t\tfor (let angle=start; angle<end; angle=angle+angleDelta) {\n\t\t\tparticleFactory(angle + Math.random() * angleDelta * randomness);\n\t\t}\n\t} else {\n\t\tfor (let angle=start; angle>end; angle=angle+angleDelta) {\n\t\t\tparticleFactory(angle + Math.random() * angleDelta * randomness);\n\t\t}\n\t}\n}\n\n\n\nfunction createBurst(count, particleFactory, startAngle=0, arcLength=PI_2) {\n\n\tconst R = 0.5 * Math.sqrt(count/Math.PI);\n\n\tconst C = 2 * R * Math.PI;\n\n\tconst C_HALF = C / 2;\n\t\n\n\tfor (let i=0; i<=C_HALF; i++) {\n\t\tconst ringAngle = i / C_HALF * PI_HALF;\n\t\tconst ringSize = Math.cos(ringAngle);\n\t\tconst partsPerFullRing = C * ringSize;\n\t\tconst partsPerArc = partsPerFullRing * (arcLength / PI_2);\n\t\t\n\t\tconst angleInc = PI_2 / partsPerFullRing;\n\t\tconst angleOffset = Math.random() * angleInc + startAngle;\n\n\t\tconst maxRandomAngleOffset = angleInc * 0.33;\n\t\t\n\t\tfor (let i=0; i<partsPerArc; i++) {\n\t\t\tconst randomAngleOffset = Math.random() * maxRandomAngleOffset;\n\t\t\tlet angle = angleInc * i + angleOffset + randomAngleOffset;\n\t\t\tparticleFactory(angle, ringSize);\n\t\t}\n\t}\n}\n\n\n\n\n\nfunction crossetteEffect(star) {\n\tconst startAngle = Math.random() * PI_HALF;\n\tcreateParticleArc(startAngle, PI_2, 4, 0.5, (angle) => {\n\t\tStar.add(\n\t\t\tstar.x,\n\t\t\tstar.y,\n\t\t\tstar.color,\n\t\t\tangle,\n\t\t\tMath.random() * 0.6 + 0.75,\n\t\t\t600\n\t\t);\n\t});\n}\n\n\nfunction floralEffect(star) {\n\tconst count = 12 + 6 * quality;\n\tcreateBurst(count, (angle, speedMult) => {\n\t\tStar.add(\n\t\t\tstar.x,\n\t\t\tstar.y,\n\t\t\tstar.color,\n\t\t\tangle,\n\t\t\tspeedMult * 2.4,\n\t\t\t1000 + Math.random() * 300,\n\t\t\tstar.speedX,\n\t\t\tstar.speedY\n\t\t);\n\t});\n\t// Queue burst flash render\n\tBurstFlash.add(star.x, star.y, 46);\n\tsoundManager.playSound('burstSmall');\n}\n\n// Floral burst with willow stars\nfunction fallingLeavesEffect(star) {\n\tcreateBurst(7, (angle, speedMult) => {\n\t\tconst newStar = Star.add(\n\t\t\tstar.x,\n\t\t\tstar.y,\n\t\t\tINVISIBLE,\n\t\t\tangle,\n\t\t\tspeedMult * 2.4,\n\t\t\t2400 + Math.random() * 600,\n\t\t\tstar.speedX,\n\t\t\tstar.speedY\n\t\t);\n\t\t\n\t\tnewStar.sparkColor = COLOR.Gold;\n\t\tnewStar.sparkFreq = 144 / quality;\n\t\tnewStar.sparkSpeed = 0.28;\n\t\tnewStar.sparkLife = 750;\n\t\tnewStar.sparkLifeVariation = 3.2;\n\t});\n\t// Queue burst flash render\n\tBurstFlash.add(star.x, star.y, 46);\n\tsoundManager.playSound('burstSmall');\n}\n\n// Crackle pops into a small cloud of golden sparks.\nfunction crackleEffect(star) {\n\tconst count = isHighQuality ? 32 : 16;\n\tcreateParticleArc(0, PI_2, count, 1.8, (angle) => {\n\t\tSpark.add(\n\t\t\tstar.x,\n\t\t\tstar.y,\n\t\t\tCOLOR.Gold,\n\t\t\tangle,\n\t\t\t// apply near cubic falloff to speed (places more particles towards outside)\n\t\t\tMath.pow(Math.random(), 0.45) * 2.4,\n\t\t\t300 + Math.random() * 200\n\t\t);\n\t});\n}\n\n\n\n\nclass Shell {\n\tconstructor(options) {\n\t\tObject.assign(this, options);\n\t\tthis.starLifeVariation = options.starLifeVariation || 0.125;\n\t\tthis.color = options.color || randomColor();\n\t\tthis.glitterColor = options.glitterColor || this.color;\n\t\t\t\t\n\n\t\tif (!this.starCount) {\n\t\t\tconst density = options.starDensity || 1;\n\t\t\tconst scaledSize = this.spreadSize / 54;\n\t\t\tthis.starCount = Math.max(6, scaledSize * scaledSize * density);\n\t\t}\n\t}\n\t\n\tlaunch(position, launchHeight) {\n\t\tconst width = stageW;\n\t\tconst height = stageH;\n\n\t\tconst hpad = 60;\n\n\t\tconst vpad = 50;\n\n\t\tconst minHeightPercent = 0.45;\n\n\t\tconst minHeight = height - height * minHeightPercent;\n\t\t\n\t\tconst launchX = position * (width - hpad * 2) + hpad;\n\t\tconst launchY = height;\n\t\tconst burstY = minHeight - (launchHeight * (minHeight - vpad));\n\t\t\n\t\tconst launchDistance = launchY - burstY;\n\n\t\tconst launchVelocity = Math.pow(launchDistance * 0.04, 0.64);\n\t\t\n\t\tconst comet = this.comet = Star.add(\n\t\t\tlaunchX,\n\t\t\tlaunchY,\n\t\t\ttypeof this.color === 'string' && this.color !== 'random' ? this.color : COLOR.White,\n\t\t\tMath.PI,\n\t\t\tlaunchVelocity * (this.horsetail ? 1.2 : 1),\n\t\t\t// Hang time is derived linearly from Vi; exact number came from testing\n\t\t\tlaunchVelocity * (this.horsetail ? 100 : 400)\n\t\t);\n\t\t\n\t\t// making comet \"heavy\" limits air drag\n\t\tcomet.heavy = true;\n\t\t// comet spark trail\n\t\tcomet.spinRadius = MyMath.random(0.32, 0.85);\n\t\tcomet.sparkFreq = 32 / quality;\n\t\tif (isHighQuality) comet.sparkFreq = 8;\n\t\tcomet.sparkLife = 320;\n\t\tcomet.sparkLifeVariation = 3;\n\t\tif (this.glitter === 'willow' || this.fallingLeaves) {\n\t\t\tcomet.sparkFreq = 20 / quality;\n\t\t\tcomet.sparkSpeed = 0.5;\n\t\t\tcomet.sparkLife = 500;\n\t\t}\n\t\tif (this.color === INVISIBLE) {\n\t\t\tcomet.sparkColor = COLOR.Gold;\n\t\t}\n\t\t\n\t\t// Randomly make comet \"burn out\" a bit early.\n\t\t// This is disabled for horsetail shells, due to their very short airtime.\n\t\tif (Math.random() > 0.4 && !this.horsetail) {\n\t\t\tcomet.secondColor = INVISIBLE;\n\t\t\tcomet.transitionTime = Math.pow(Math.random(), 1.5) * 700 + 500;\n\t\t}\n\t\t\n\t\tcomet.onDeath = comet => this.burst(comet.x, comet.y);\n\t\t\n\t\tsoundManager.playSound('lift');\n\t}\n\t\n\tburst(x, y) {\n\t\t// Set burst speed so overall burst grows to set size. This specific formula was derived from testing, and is affected by simulated air drag.\n\t\tconst speed = this.spreadSize / 96;\n\n\t\tlet color, onDeath, sparkFreq, sparkSpeed, sparkLife;\n\t\tlet sparkLifeVariation = 0.25;\n\t\t// Some death effects, like crackle, play a sound, but should only be played once.\n\t\tlet playedDeathSound = false;\n\t\t\n\t\tif (this.crossette) onDeath = (star) => {\n\t\t\tif (!playedDeathSound) {\n\t\t\t\tsoundManager.playSound('crackleSmall');\n\t\t\t\tplayedDeathSound = true;\n\t\t\t}\n\t\t\tcrossetteEffect(star);\n\t\t}\n\t\tif (this.crackle) onDeath = (star) => {\n\t\t\tif (!playedDeathSound) {\n\t\t\t\tsoundManager.playSound('crackle');\n\t\t\t\tplayedDeathSound = true;\n\t\t\t}\n\t\t\tcrackleEffect(star);\n\t\t}\n\t\tif (this.floral) onDeath = floralEffect;\n\t\tif (this.fallingLeaves) onDeath = fallingLeavesEffect;\n\t\t\n\t\tif (this.glitter === 'light') {\n\t\t\tsparkFreq = 400;\n\t\t\tsparkSpeed = 0.3;\n\t\t\tsparkLife = 300;\n\t\t\tsparkLifeVariation = 2;\n\t\t}\n\t\telse if (this.glitter === 'medium') {\n\t\t\tsparkFreq = 200;\n\t\t\tsparkSpeed = 0.44;\n\t\t\tsparkLife = 700;\n\t\t\tsparkLifeVariation = 2;\n\t\t}\n\t\telse if (this.glitter === 'heavy') {\n\t\t\tsparkFreq = 80;\n\t\t\tsparkSpeed = 0.8;\n\t\t\tsparkLife = 1400;\n\t\t\tsparkLifeVariation = 2;\n\t\t}\n\t\telse if (this.glitter === 'thick') {\n\t\t\tsparkFreq = 16;\n\t\t\tsparkSpeed = isHighQuality ? 1.65 : 1.5;\n\t\t\tsparkLife = 1400;\n\t\t\tsparkLifeVariation = 3;\n\t\t}\n\t\telse if (this.glitter === 'streamer') {\n\t\t\tsparkFreq = 32;\n\t\t\tsparkSpeed = 1.05;\n\t\t\tsparkLife = 620;\n\t\t\tsparkLifeVariation = 2;\n\t\t}\n\t\telse if (this.glitter === 'willow') {\n\t\t\tsparkFreq = 120;\n\t\t\tsparkSpeed = 0.34;\n\t\t\tsparkLife = 1400;\n\t\t\tsparkLifeVariation = 3.8;\n\t\t}\n\t\t\n\t\t// Apply quality to spark count\n\t\tsparkFreq = sparkFreq / quality;\n\t\t\n\t\t// Star factory for primary burst, pistils, and streamers.\n\t\tlet firstStar = true;\n\t\tconst starFactory = (angle, speedMult) => {\n\t\t\t// For non-horsetail shells, compute an initial vertical speed to add to star burst.\n\t\t\t// The magic number comes from testing what looks best. The ideal is that all shell\n\t\t\t// bursts appear visually centered for the majority of the star life (excl. willows etc.)\n\t\t\tconst standardInitialSpeed = this.spreadSize / 1800;\n\t\t\t\n\t\t\tconst star = Star.add(\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tcolor || randomColor(),\n\t\t\t\tangle,\n\t\t\t\tspeedMult * speed,\n\t\t\t\t// add minor variation to star life\n\t\t\t\tthis.starLife + Math.random() * this.starLife * this.starLifeVariation,\n\t\t\t\tthis.horsetail ? this.comet && this.comet.speedX : 0,\n\t\t\t\tthis.horsetail ? this.comet && this.comet.speedY : -standardInitialSpeed\n\t\t\t);\n\t\n\t\t\tif (this.secondColor) {\n\t\t\t\tstar.transitionTime = this.starLife * (Math.random() * 0.05 + 0.32);\n\t\t\t\tstar.secondColor = this.secondColor;\n\t\t\t}\n\n\t\t\tif (this.strobe) {\n\t\t\t\tstar.transitionTime = this.starLife * (Math.random() * 0.08 + 0.46);\n\t\t\t\tstar.strobe = true;\n\t\t\t\t// How many milliseconds between switch of strobe state \"tick\". Note that the strobe pattern\n\t\t\t\t// is on:off:off, so this is the \"on\" duration, while the \"off\" duration is twice as long.\n\t\t\t\tstar.strobeFreq = Math.random() * 20 + 40;\n\t\t\t\tif (this.strobeColor) {\n\t\t\t\t\tstar.secondColor = this.strobeColor;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstar.onDeath = onDeath;\n\n\t\t\tif (this.glitter) {\n\t\t\t\tstar.sparkFreq = sparkFreq;\n\t\t\t\tstar.sparkSpeed = sparkSpeed;\n\t\t\t\tstar.sparkLife = sparkLife;\n\t\t\t\tstar.sparkLifeVariation = sparkLifeVariation;\n\t\t\t\tstar.sparkColor = this.glitterColor;\n\t\t\t\tstar.sparkTimer = Math.random() * star.sparkFreq;\n\t\t\t}\n\t\t};\n\t\t\n\t\t\n\t\tif (typeof this.color === 'string') {\n\t\t\tif (this.color === 'random') {\n\t\t\t\tcolor = null; // falsey value creates random color in starFactory\n\t\t\t} else {\n\t\t\t\tcolor = this.color;\n\t\t\t}\n\t\t\t\n\t\t\t// Rings have positional randomness, but are rotated randomly\n\t\t\tif (this.ring) {\n\t\t\t\tconst ringStartAngle = Math.random() * Math.PI;\n\t\t\t\tconst ringSquash = Math.pow(Math.random(), 2) * 0.85 + 0.15;;\n\t\t\t\t\n\t\t\t\tcreateParticleArc(0, PI_2, this.starCount, 0, angle => {\n\t\t\t\t\t// Create a ring, squashed horizontally\n\t\t\t\t\tconst initSpeedX = Math.sin(angle) * speed * ringSquash;\n\t\t\t\t\tconst initSpeedY = Math.cos(angle) * speed;\n\t\t\t\t\t// Rotate ring\n\t\t\t\t\tconst newSpeed = MyMath.pointDist(0, 0, initSpeedX, initSpeedY);\n\t\t\t\t\tconst newAngle = MyMath.pointAngle(0, 0, initSpeedX, initSpeedY) + ringStartAngle;\n\t\t\t\t\tconst star = Star.add(\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\tcolor,\n\t\t\t\t\t\tnewAngle,\n\t\t\t\t\t\t// apply near cubic falloff to speed (places more particles towards outside)\n\t\t\t\t\t\tnewSpeed,//speed,\n\t\t\t\t\t\t// add minor variation to star life\n\t\t\t\t\t\tthis.starLife + Math.random() * this.starLife * this.starLifeVariation\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tif (this.glitter) {\n\t\t\t\t\t\tstar.sparkFreq = sparkFreq;\n\t\t\t\t\t\tstar.sparkSpeed = sparkSpeed;\n\t\t\t\t\t\tstar.sparkLife = sparkLife;\n\t\t\t\t\t\tstar.sparkLifeVariation = sparkLifeVariation;\n\t\t\t\t\t\tstar.sparkColor = this.glitterColor;\n\t\t\t\t\t\tstar.sparkTimer = Math.random() * star.sparkFreq;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Normal burst\n\t\t\telse {\n\t\t\t\tcreateBurst(this.starCount, starFactory);\n\t\t\t}\n\t\t}\n\t\telse if (Array.isArray(this.color)) {\n\t\t\tif (Math.random() < 0.5) {\n\t\t\t\tconst start = Math.random() * Math.PI;\n\t\t\t\tconst start2 = start + Math.PI;\n\t\t\t\tconst arc = Math.PI;\n\t\t\t\tcolor = this.color[0];\n\t\t\t\t// Not creating a full arc automatically reduces star count.\n\t\t\t\tcreateBurst(this.starCount, starFactory, start, arc);\n\t\t\t\tcolor = this.color[1];\n\t\t\t\tcreateBurst(this.starCount, starFactory, start2, arc);\n\t\t\t} else {\n\t\t\t\tcolor = this.color[0];\n\t\t\t\tcreateBurst(this.starCount / 2, starFactory);\n\t\t\t\tcolor = this.color[1];\n\t\t\t\tcreateBurst(this.starCount / 2, starFactory);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new Error('Invalid shell color. Expected string or array of strings, but got: ' + this.color);\n\t\t}\n\t\t\n\t\tif (this.pistil) {\n\t\t\tconst innerShell = new Shell({\n\t\t\t\tspreadSize: this.spreadSize * 0.5,\n\t\t\t\tstarLife: this.starLife * 0.6,\n\t\t\t\tstarLifeVariation: this.starLifeVariation,\n\t\t\t\tstarDensity: 1.4,\n\t\t\t\tcolor: this.pistilColor,\n\t\t\t\tglitter: 'light',\n\t\t\t\tglitterColor: this.pistilColor === COLOR.Gold ? COLOR.Gold : COLOR.White\n\t\t\t});\n\t\t\tinnerShell.burst(x, y);\n\t\t}\n\t\t\n\t\tif (this.streamers) {\n\t\t\tconst innerShell = new Shell({\n\t\t\t\tspreadSize: this.spreadSize * 0.9,\n\t\t\t\tstarLife: this.starLife * 0.8,\n\t\t\t\tstarLifeVariation: this.starLifeVariation,\n\t\t\t\tstarCount: Math.floor(Math.max(6, this.spreadSize / 45)),\n\t\t\t\tcolor: COLOR.White,\n\t\t\t\tglitter: 'streamer'\n\t\t\t});\n\t\t\tinnerShell.burst(x, y);\n\t\t}\n\t\t\n\t\t// Queue burst flash render\n\t\tBurstFlash.add(x, y, this.spreadSize / 4);\n\n\n\t\tif (this.comet) {\n\n\t\t\tconst maxDiff = 2;\n\t\t\tconst sizeDifferenceFromMaxSize = Math.min(maxDiff, shellSizeSelector() - this.shellSize);\n\t\t\tconst soundScale = (1 - sizeDifferenceFromMaxSize / maxDiff) * 0.3 + 0.7;\n\t\t\tsoundManager.playSound('burst', soundScale);\n\t\t}\n\t}\n}\n\n\n\nconst BurstFlash = {\n\tactive: [],\n\t_pool: [],\n\t\n\t_new() {\n\t\treturn {}\n\t},\n\t\n\tadd(x, y, radius) {\n\t\tconst instance = this._pool.pop() || this._new();\n\t\t\n\t\tinstance.x = x;\n\t\tinstance.y = y;\n\t\tinstance.radius = radius;\n\t\t\n\t\tthis.active.push(instance);\n\t\treturn instance;\n\t},\n\t\n\treturnInstance(instance) {\n\t\tthis._pool.push(instance);\n\t}\n};\n\n\n\n// Helper to generate objects for storing active particles.\n// Particles are stored in arrays keyed by color (code, not name) for improved rendering performance.\nfunction createParticleCollection() {\n\tconst collection = {};\n\tCOLOR_CODES_W_INVIS.forEach(color => {\n\t\tcollection[color] = [];\n\t});\n\treturn collection;\n}\n\n\n// Star properties (WIP)\n// -----------------------\n// transitionTime - how close to end of life that star transition happens\n\nconst Star = {\n\t// Visual properties\n\tdrawWidth: 3,\n\tairDrag: 0.98,\n\tairDragHeavy: 0.992,\n\t\n\t// Star particles will be keyed by color\n\tactive: createParticleCollection(),\n\t_pool: [],\n\t\n\t_new() {\n\t\treturn {};\n\t},\n\n\tadd(x, y, color, angle, speed, life, speedOffX, speedOffY) {\n\t\tconst instance = this._pool.pop() || this._new();\n\t\t\n\t\tinstance.visible = true;\n\t\tinstance.heavy = false;\n\t\tinstance.x = x;\n\t\tinstance.y = y;\n\t\tinstance.prevX = x;\n\t\tinstance.prevY = y;\n\t\tinstance.color = color;\n\t\tinstance.speedX = Math.sin(angle) * speed + (speedOffX || 0);\n\t\tinstance.speedY = Math.cos(angle) * speed + (speedOffY || 0);\n\t\tinstance.life = life;\n\t\tinstance.fullLife = life;\n\t\tinstance.spinAngle = Math.random() * PI_2;\n\t\tinstance.spinSpeed = 0.8;\n\t\tinstance.spinRadius = 0;\n\t\tinstance.sparkFreq = 0; // ms between spark emissions\n\t\tinstance.sparkSpeed = 1;\n\t\tinstance.sparkTimer = 0;\n\t\tinstance.sparkColor = color;\n\t\tinstance.sparkLife = 750;\n\t\tinstance.sparkLifeVariation = 0.25;\n\t\tinstance.strobe = false;\n\t\t\n\t\tthis.active[color].push(instance);\n\t\treturn instance;\n\t},\n\n\t// Public method for cleaning up and returning an instance back to the pool.\n\treturnInstance(instance) {\n\t\t// Call onDeath handler if available (and pass it current star instance)\n\t\tinstance.onDeath && instance.onDeath(instance);\n\t\t// Clean up\n\t\tinstance.onDeath = null;\n\t\tinstance.secondColor = null;\n\t\tinstance.transitionTime = 0;\n\t\tinstance.colorChanged = false;\n\t\t// Add back to the pool.\n\t\tthis._pool.push(instance);\n\t}\n};\n\n\nconst Spark = {\n\t// Visual properties\n\tdrawWidth: 0, // set in `configDidUpdate()`\n\tairDrag: 0.9,\n\t\n\t// Star particles will be keyed by color\n\tactive: createParticleCollection(),\n\t_pool: [],\n\t\n\t_new() {\n\t\treturn {};\n\t},\n\n\tadd(x, y, color, angle, speed, life) {\n\t\tconst instance = this._pool.pop() || this._new();\n\t\t\n\t\tinstance.x = x;\n\t\tinstance.y = y;\n\t\tinstance.prevX = x;\n\t\tinstance.prevY = y;\n\t\tinstance.color = color;\n\t\tinstance.speedX = Math.sin(angle) * speed;\n\t\tinstance.speedY = Math.cos(angle) * speed;\n\t\tinstance.life = life;\n\t\t\n\t\tthis.active[color].push(instance);\n\t\treturn instance;\n\t},\n\n\t// Public method for cleaning up and returning an instance back to the pool.\n\treturnInstance(instance) {\n\t\t// Add back to the pool.\n\t\tthis._pool.push(instance);\n\t}\n};\n\n\n\nconst soundManager = {\n\tbaseURL: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/',\n\tctx: new (window.AudioContext || window.webkitAudioContext),\n\tsources: {\n\t\tlift: {\n\t\t\tvolume: 1,\n\t\t\tplaybackRateMin: 0.85,\n\t\t\tplaybackRateMax: 0.95,\n\t\t\tfileNames: [\n\t\t\t   \n\t\t\t\t'lift1.mp3',\n\t\t\t\t'lift2.mp3',\n\t\t\t\t'lift3.mp3'\n\t\t\t]\n\t\t},\n\t\tburst: {\n\t\t\tvolume: 1,\n\t\t\tplaybackRateMin: 0.8,\n\t\t\tplaybackRateMax: 0.9,\n\t\t\tfileNames: [\n\t\t\t\t'burst1.mp3',\n\t\t\t\t'burst2.mp3'\n\t\t\t]\n\t\t},\n\t\tburstSmall: {\n\t\t\tvolume: 0.25,\n\t\t\tplaybackRateMin: 0.8,\n\t\t\tplaybackRateMax: 1,\n\t\t\tfileNames: [\n\t\t\t\t'burst-sm-1.mp3',\n\t\t\t\t'burst-sm-2.mp3'\n\t\t\t]\n\t\t},\n\t\tcrackle: {\n\t\t\tvolume: 0.2,\n\t\t\tplaybackRateMin: 1,\n\t\t\tplaybackRateMax: 1,\n\t\t\tfileNames: ['crackle1.mp3']\n\t\t},\n\t\tcrackleSmall: {\n\t\t\tvolume: 0.3,\n\t\t\tplaybackRateMin: 1,\n\t\t\tplaybackRateMax: 1,\n\t\t\tfileNames: ['crackle-sm-1.mp3']\n\t\t}\n\t},\n\n\tpreload() {\n\t\tconst allFilePromises = [];\n\n\t\tfunction checkStatus(response) {\n\t\t\tif (response.status >= 200 && response.status < 300) {\n\t\t\t\treturn response;\n\t\t\t}\n\t\t\tconst customError = new Error(response.statusText);\n\t\t\tcustomError.response = response;\n\t\t\tthrow customError;\n\t\t}\n\n\t\tconst types = Object.keys(this.sources);\n\t\ttypes.forEach(type => {\n\t\t\tconst source = this.sources[type];\n\t\t\tconst { fileNames } = source;\n\t\t\tconst filePromises = [];\n\t\t\tfileNames.forEach(fileName => {\n\t\t\t\tconst fileURL = this.baseURL + fileName;\n\t\t\t\t// Promise will resolve with decoded audio buffer.\n\t\t\t\tconst promise = fetch(fileURL)\n\t\t\t\t\t.then(checkStatus)\n\t\t\t\t\t.then(response => response.arrayBuffer())\n\t\t\t\t\t.then(data => new Promise(resolve => {\n\t\t\t\t\t\tthis.ctx.decodeAudioData(data, resolve);\n\t\t\t\t\t}));\n\n\t\t\t\tfilePromises.push(promise);\n\t\t\t\tallFilePromises.push(promise);\n\t\t\t});\n\n\t\t\tPromise.all(filePromises)\n\t\t\t\t.then(buffers => {\n\t\t\t\t\tsource.buffers = buffers;\n\t\t\t\t});\n\t\t});\n\n\t\treturn Promise.all(allFilePromises);\n\t},\n\t\n\tpauseAll() {\n\t\tthis.ctx.suspend();\n\t},\n\n\tresumeAll() {\n\n\t\tthis.playSound('lift', 0);\n\t\tsetTimeout(() => {\n\t\t\tthis.ctx.resume();\n\t\t}, 250);\n\t},\n\t\n\n\t_lastSmallBurstTime: 0,\n\n\n\tplaySound(type, scale=1) {\n\n\t\tscale = MyMath.clamp(scale, 0, 1);\n\n\n\t\tif (!canPlaySoundSelector() || simSpeed < 0.95) {\n\t\t\treturn;\n\t\t}\n\t\t\n\n\t\tif (type === 'burstSmall') {\n\t\t\tconst now = Date.now();\n\t\t\tif (now - this._lastSmallBurstTime < 20) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._lastSmallBurstTime = now;\n\t\t}\n\t\t\n\t\tconst source = this.sources[type];\n\n\t\tif (!source) {\n\t\t\tthrow new Error(\"Sound of type '${type}' doesn't exist.\");\n\t\t}\n\t\t\n\t\tconst initialVolume = source.volume;\n\t\tconst initialPlaybackRate = MyMath.random(\n\t\t\tsource.playbackRateMin,\n\t\t\tsource.playbackRateMax\n\t\t);\n\t\t\n\t\t// Volume descreases with scale.\n\t\tconst scaledVolume = initialVolume * scale;\n\t\t// Playback rate increases with scale. For this, we map the scale of 0-1 to a scale of 2-1.\n\t\t// So at a scale of 1, sound plays normally, but as scale approaches 0 speed approaches double.\n\t\tconst scaledPlaybackRate = initialPlaybackRate * (2 - scale);\n\t\t\n\t\tconst gainNode = this.ctx.createGain();\n\t\tgainNode.gain.value = scaledVolume;\n\n\t\tconst buffer = MyMath.randomChoice(source.buffers);\n\t\tconst bufferSource = this.ctx.createBufferSource();\n\t\tbufferSource.playbackRate.value = scaledPlaybackRate;\n\t\tbufferSource.buffer = buffer;\n\t\tbufferSource.connect(gainNode);\n\t\tgainNode.connect(this.ctx.destination);\n\t\tbufferSource.start(0);\n\t}\n};\n\n\n\n\n\n\nfunction setLoadingStatus(status) {\n\tdocument.querySelector('.loading-init__status').textContent = status;\n}\n\n\nif (IS_HEADER) {\n\tinit();\n} else {\n\n\tsetTimeout(() => {\n\t\tsoundManager.preload()\n\t\t.then(\n\t\t\tinit,\n\t\t\treason => {\n\n\t\t\t\tinit();\n\n\t\t\t\treturn Promise.reject(reason);\n\t\t\t}\n\t\t);\n\t}, 0);\n}\n\n//# sourceURL=webpack://yanhua/./js/script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./js/script.js"]();
/******/ 	
/******/ })()
;